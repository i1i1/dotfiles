#!/usr/bin/env bash
diff() {
    tmppipe=$(mktemp)
    chmod 600 $tmppipe
    env diff -u --color=always "$@" > $tmppipe
    ret=$?
    case $ret in
        1) cat $tmppipe | less -R ;;
        0) echo Files are same ;;
    esac
    rm $tmppipe
    return $ret
}

edit() {
    if which emacs &>/dev/null; then
        emacsclient -a "" -c $* &>/dev/null &
        disown
    else
        env vim $*
    fi
}

lsips() {
    sudo true # just asking for sudo to make output look synchronous

    ifconfig | \
        awk '
    /^$/ {
        a = 1
        next
    }
    a == 1 {
        a = 2
        dev = $1
        next
    }
    a == 2 && /inet / {
        a = 0
        printf("% -8s %s\n", dev, $2)
    }' | sort -h

    echo

    sudo nmap -n -sn 192.168.88.0/24 | \
        sed 1d | \
        awk 'FNR % 3 != 2' | \
        sed '$d' | sed '$d' | \
        awk '
    FNR % 2 == 1 {
        ip = $5
    }
    FNR % 2 == 0 {
        sub(/^.*\(/, "")
        sub(/\)$/, "")
        printf("% -15s %s\n", ip":", $0)
    }' | sort -h
}

lsssh() {
    awk '/^Host /{host=$2} /HostName/{hostname=$2} /User/{user=$2}
         /^$/{printf("% -20s%s@%s\n", host":", user, hostname)}' ~/.ssh/config
}

ssh() {
    is_new_ssh() {
        url=$(echo $1|awk -F@ '/@/{print $2;exit} {print}')
        (
            cut -d' ' -f1 ~/.ssh/known_hosts
            awk '/^Host/{print $2}' ~/.ssh/config
        ) | grep -qF $url && return 1
        return 0
    }
    add_alias() {
        user=$(echo $1|cut -d@ -f1)
        url=$(echo $1|cut -d@ -f2)
        yellow "New alias for "
        red    "$1: "
        read name
        (
            echo "Host $name"
            echo "     HostName $url"
            echo "     User $user"
            echo
        )  >> ~/.ssh/config 
    }
    connect() {
        env ssh $1 -t \
            "export RCFG=$RCFG;
             export RCFG_DIR=\$HOME/.sh/\$RCFG/;
             export RCFG_EXT=1;
             bash --rcfile \$RCFG_DIR/rc"
    }
    copy_config() { tar cfh - -C ~ .sh/ | ssh $1 tar xfC - '~'; }
    color() {
        printf "\033[0;$1m"
        shift 1
        printf "$@"
        printf '\033[0m'
    }
    red()    { color 31 "$@" ; }
    green()  { color 32 "$@" ; }
    yellow() { color 33 "$@" ; }

    [ $# != 1 ] && env ssh $@ && return $?
    host=$1

    is_new_ssh $host || {
        copy_config $host
        connect $host
        return $?
    }

    red "$host "
    green "is new ssh host.\n"
    add_alias $host
    ssh-copy-id $host

    green "Copying shell configuration\n"
    copy_config $host

    green "Done! Now loging in\n"
    connect $host
}

_gcloud_create() {
    PROJECT=$1
    MACHINE_TYPE=$2
    DISK_SIZE=$3
    MACHINE_NAME=$5
    if [ "$4" = true ]; then
        FLAG=--google-preemptible
    fi

    docker-machine ls -q | grep ^"$MACHINE_NAME"$ || {
        docker-machine create \
                       --driver google \
                       $FLAG \
                       --google-disk-size $DISK_SIZE \
                       --google-machine-type $MACHINE_TYPE \
                       --google-project $PROJECT \
                       --google-zone europe-north1-b \
                       $MACHINE_NAME
    }

    eval $(docker-machine env $MACHINE_NAME)
}

dcm_work() { _gcloud_create copper-tracker-270409 n1-standard-16 35 false i1i1; }

unalias g grep ls l la ll "..." "...."

..()   { cd ..;   }
...()  { ..;  ..; }
....() { ...; ..; }
ca()   { cargo "$@"; }
dc()   { docker "$@"; }
dcc()  { docker-compose "$@"; }
dcm()  { docker-machine "$@"; }
ec()   { edit "$@"; }
g()    { git "$@"; }
git()  { git_ "$@"; }
git_() { XDG_CONFIG_HOME=$RCFG_DIR env git "$@"; }
grep() { env grep --color=auto "$@"; }
l()    { ls "$@"; }
la()   { ll -a "$@"; }
less() { env less -R "$@"; }
ll()   { ls -l "$@"; }
ls()   { ls_ --color=auto "$@"; }
ls_()  { exa / &>/dev/null && exa --color-scale "$@" || env ls "$@"; }
ls_()  { exa / &>/dev/null && exa --color-scale "$@" || env ls "$@"; }
rg()   { env rg --color=auto "$@"; }
t()    { todotxt-machine $TODO_DIR/todo.txt $TODO_DIR/archive.txt;  }
vi()   { vim "$@"; }
vim()  { edit "$@"; }
wttr() { cat ~/.cache/wttr; }

#
# In order to make parallel loops like this:
#
#   for ar in *.tar; pdo
#       tar xf $ar
#   pdone
#
alias pdo='do while [ $(jobs | wc -l) = 8 ]; do sleep 0.01; done; ('
alias pdone=') & done; wait'
